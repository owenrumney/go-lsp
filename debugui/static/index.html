<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>LSP Debug UI</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; background: #1e1e2e; color: #cdd6f4; height: 100vh; display: flex; flex-direction: column; }
  #topbar { display: flex; gap: 8px; padding: 8px 12px; background: #181825; border-bottom: 1px solid #313244; align-items: center; flex-shrink: 0; }
  #topbar h1 { font-size: 14px; color: #89b4fa; margin-right: 8px; white-space: nowrap; }
  #topbar input, #topbar select { background: #313244; border: 1px solid #45475a; color: #cdd6f4; padding: 4px 8px; border-radius: 4px; font-size: 13px; }
  #search { flex: 1; max-width: 300px; }
  #counter { font-size: 12px; color: #6c7086; margin-left: auto; white-space: nowrap; }
  #main { display: flex; flex: 1; overflow: hidden; }
  #list { width: 40%; border-right: 1px solid #313244; overflow-y: auto; }
  #detail { width: 60%; overflow-y: auto; padding: 12px; }
  .entry { padding: 6px 0; cursor: pointer; border-bottom: 1px solid #1e1e2e; font-size: 13px; display: flex; align-items: center; }
  .entry:hover { background: #313244; }
  .entry.selected { background: #45475a; }
  .col-time { color: #6c7086; font-size: 11px; width: 90px; padding-left: 12px; flex-shrink: 0; }
  .col-type { width: 72px; flex-shrink: 0; }
  .col-dir { width: 20px; flex-shrink: 0; text-align: center; }
  .col-dir.in { color: #a6e3a1; }
  .col-dir.out { color: #f38ba8; }
  .col-latency { width: 56px; flex-shrink: 0; text-align: right; font-size: 11px; padding-right: 8px; }
  .col-method { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 12px; }
  .badge { font-size: 10px; padding: 1px 5px; border-radius: 3px; }
  .badge.request { background: #89b4fa22; color: #89b4fa; }
  .badge.notification { background: #f9e2af22; color: #f9e2af; }
  .latency { color: #6c7086; }
  .latency.slow { color: #f9e2af; }
  .latency.very-slow { color: #f38ba8; }
  .pending-dot { display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: #89b4fa; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .error-indicator { color: #f38ba8; font-size: 11px; margin-right: 2px; }
  #detail h3 { font-size: 13px; color: #89b4fa; margin: 12px 0 6px; }
  #detail h3:first-child { margin-top: 0; }
  #detail pre { background: #181825; padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; white-space: pre-wrap; word-break: break-all; line-height: 1.5; }
  #detail .meta { font-size: 12px; color: #6c7086; margin-bottom: 8px; }
  .empty { padding: 40px; text-align: center; color: #6c7086; }
  #new-indicator { display: none; position: fixed; bottom: 16px; left: calc(20% - 60px); background: #89b4fa; color: #1e1e2e; padding: 4px 12px; border-radius: 12px; font-size: 12px; cursor: pointer; z-index: 10; }
</style>
</head>
<body>
<div id="topbar">
  <h1>LSP Debug</h1>
  <input id="search" type="text" placeholder="Search methods & bodies...">
  <select id="direction-filter">
    <option value="">All directions</option>
    <option value="client→server">client → server</option>
    <option value="server→client">server → client</option>
  </select>
  <select id="type-filter">
    <option value="">All types</option>
    <option value="request">request</option>
    <option value="notification">notification</option>
  </select>
  <span id="counter">0 messages</span>
</div>
<div id="main">
  <div id="list"><div class="empty">Waiting for messages...</div></div>
  <div id="detail"><div class="empty">Select a message to view details</div></div>
</div>
<div id="new-indicator" onclick="scrollToBottom()">↓ New messages</div>

<script>
const listEl = document.getElementById('list');
const detailEl = document.getElementById('detail');
const searchEl = document.getElementById('search');
const dirFilter = document.getElementById('direction-filter');
const typeFilter = document.getElementById('type-filter');
const counterEl = document.getElementById('counter');
const indicatorEl = document.getElementById('new-indicator');

let allEntries = [];
let entryById = {};
let selectedId = null;
let autoScroll = true;

function formatTime(ts) {
  const d = new Date(ts);
  return d.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' }) + '.' + String(d.getMilliseconds()).padStart(3, '0');
}

function formatLatency(ms) {
  if (ms < 1) return '<1ms';
  if (ms < 1000) return Math.round(ms) + 'ms';
  return (ms / 1000).toFixed(1) + 's';
}

function latencyClass(ms) {
  if (ms > 5000) return 'very-slow';
  if (ms > 1000) return 'slow';
  return '';
}

// Returns rows for the list: requests and notifications only (responses are merged into their request).
function getListRows() {
  return allEntries.filter(e => e.msgType === 'request' || e.msgType === 'notification');
}

function matchesFilter(e) {
  const dir = dirFilter.value;
  const type_ = typeFilter.value;
  const q = searchEl.value.toLowerCase();
  if (dir && e.direction !== dir) return false;
  if (type_ && e.msgType !== type_) return false;
  if (q) {
    let matchText = e.method.toLowerCase() + JSON.stringify(e.body).toLowerCase();
    // Also search in paired response body.
    if (e.pairedWith >= 0) {
      const resp = entryById[e.pairedWith];
      if (resp) matchText += JSON.stringify(resp.body).toLowerCase();
    }
    if (!matchText.includes(q)) return false;
  }
  return true;
}

function renderList() {
  const rows = getListRows().filter(matchesFilter);
  counterEl.textContent = rows.length + ' messages';
  if (rows.length === 0) {
    listEl.innerHTML = '<div class="empty">No matching messages</div>';
    return;
  }
  listEl.innerHTML = rows.map(e => {
    const isIn = e.direction === 'client\u2192server';
    let latencyHtml = '';
    if (e.msgType === 'request') {
      if (e.pairedWith >= 0) {
        const resp = entryById[e.pairedWith];
        if (resp) {
          const ms = new Date(resp.timestamp) - new Date(e.timestamp);
          const hasError = resp.body && JSON.stringify(resp.body).includes('"error"');
          const errHtml = hasError ? '<span class="error-indicator">err </span>' : '';
          latencyHtml = `${errHtml}<span class="latency ${latencyClass(ms)}">${formatLatency(ms)}</span>`;
        }
      } else {
        latencyHtml = '<span class="pending-dot"></span>';
      }
    }
    return `<div class="entry ${e.id === selectedId ? 'selected' : ''}" data-id="${e.id}">
      <span class="col-time">${formatTime(e.timestamp)}</span>
      <span class="col-type"><span class="badge ${e.msgType}">${e.msgType}</span></span>
      <span class="col-dir ${isIn ? 'in' : 'out'}">${isIn ? '\u2192' : '\u2190'}</span>
      <span class="col-latency">${latencyHtml}</span>
      <span class="col-method">${e.method}</span>
    </div>`;
  }).join('');
}

function renderDetail() {
  if (selectedId === null) {
    detailEl.innerHTML = '<div class="empty">Select a message to view details</div>';
    return;
  }
  const e = entryById[selectedId];
  if (!e) return;

  let html = `<div class="meta">#${e.id} \u00b7 ${formatTime(e.timestamp)} \u00b7 ${e.direction} \u00b7 ${e.msgType}${e.rpcId ? ' \u00b7 id: ' + e.rpcId : ''}</div>`;

  if (e.msgType === 'request') {
    html += '<h3>Request</h3>';
    html += '<pre>' + escapeHtml(prettyJson(e.body)) + '</pre>';
    if (e.pairedWith >= 0) {
      const resp = entryById[e.pairedWith];
      if (resp) {
        const ms = new Date(resp.timestamp) - new Date(e.timestamp);
        html += `<h3>Response <span class="latency ${latencyClass(ms)}">(${formatLatency(ms)})</span></h3>`;
        html += '<pre>' + escapeHtml(prettyJson(resp.body)) + '</pre>';
      }
    } else {
      html += '<h3>Response</h3><div class="meta">Pending...</div>';
    }
  } else if (e.msgType === 'notification') {
    html += '<h3>Notification</h3>';
    html += '<pre>' + escapeHtml(prettyJson(e.body)) + '</pre>';
  } else {
    html += '<h3>Message</h3>';
    html += '<pre>' + escapeHtml(prettyJson(e.body)) + '</pre>';
  }

  detailEl.innerHTML = html;
}

function prettyJson(obj) {
  try {
    if (typeof obj === 'string') obj = JSON.parse(obj);
    return JSON.stringify(obj, null, 2);
  } catch { return String(obj); }
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function addEntry(e) {
  entryById[e.id] = e;
  // Update paired entry if this is a response.
  if (e.pairedWith >= 0) {
    const req = entryById[e.pairedWith];
    if (req && req.pairedWith < 0) req.pairedWith = e.id;
  }
  allEntries.push(e);
}

listEl.addEventListener('click', (ev) => {
  const entry = ev.target.closest('.entry');
  if (!entry) return;
  selectedId = parseInt(entry.dataset.id, 10);
  renderList();
  renderDetail();
});

let searchTimeout;
searchEl.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => { renderList(); }, 200);
});
dirFilter.addEventListener('change', renderList);
typeFilter.addEventListener('change', renderList);

listEl.addEventListener('scroll', () => {
  const atBottom = listEl.scrollHeight - listEl.scrollTop - listEl.clientHeight < 50;
  autoScroll = atBottom;
  if (atBottom) indicatorEl.style.display = 'none';
});

function scrollToBottom() {
  listEl.scrollTop = listEl.scrollHeight;
  autoScroll = true;
  indicatorEl.style.display = 'none';
}

// Initial load
fetch('/api/messages?offset=0&limit=10000')
  .then(r => r.json())
  .then(entries => {
    entries.forEach(addEntry);
    renderList();
    scrollToBottom();
  });

// WebSocket for live updates
function connectWS() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const ws = new WebSocket(proto + '//' + location.host + '/ws');
  ws.onmessage = (ev) => {
    const e = JSON.parse(ev.data);
    addEntry(e);
    renderList();
    if (selectedId !== null) renderDetail();
    if (autoScroll) {
      scrollToBottom();
    } else {
      indicatorEl.style.display = 'block';
    }
  };
  ws.onclose = () => setTimeout(connectWS, 2000);
}
connectWS();
</script>
</body>
</html>
